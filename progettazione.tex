\section{Progettazione}

\subsection{Package Diagram}
Il Package Diagram rappresenta l’organizzazione modulare del sistema e 
le dipendenze tra i principali sottosistemi.

I package principali sono:

\begin{itemize}
    \item \textbf{Domain Model}: contiene le entità e le enumerazioni che 
    modellano i concetti fondamentali del dominio (User, Group, Membership, 
    Expense, Settlement, Balance). Questo livello definisce i comportamenti 
    propri delle entità e le regole che ne governano lo stato, rimanendo 
    indipendente dagli altri livelli applicativi.
    
    Il Domain Model è stato a sua volta suddiviso in 3 sotto-package:
    \begin{itemize}
        \item \texttt{registry}: contiene le entità relative a utenti e gruppi
        \item \texttt{accounting}: contiene le entità relative alla contabilità
        \item \texttt{events}: contiene l'infrastruttura per il pattern Observer
    \end{itemize}

    \begin{figure} [ht]
        \centering
        \includegraphics[width=1\linewidth]{img/package_domain.png}
        \caption{Suddivisione del Domain Model in sotto-package}
    \end{figure}

    \item \textbf{Data Access Layer (ORM)}: gestisce la persistenza dei dati tramite il pattern DAO, isolando il resto dell’applicazione dai dettagli di accesso al database.
    
    \item \textbf{Service Layer}: implementa i casi d’uso applicativi 
    coordinando più entità di dominio e interagendo con i DAO. È responsabile della gestione delle transazioni e del wiring degli Observer.

    \item \textbf{Controller Layer}: rappresenta il punto di accesso ai casi 
    d’uso dal lato CLI. I controller validano le richieste e delegano la 
    logica applicativa ai Service.

    \item \textbf{Util}: contiene componenti di supporto riutilizzabili. 
    Include \texttt{PasswordHasher}, utilizzato per la gestione 
    delle password.

    \begin{figure} [ht]
        \centering
        \includegraphics[width=1\linewidth]{img/packages.png}
        \caption{Dipendenze tra i package Controller, Service, ORM e Util}
    \end{figure}

    \item \textbf{Exception}: raccoglie le eccezioni applicative 
    personalizzate (\texttt{DomainException, DAOException, 
    UnauthorizedException, EntityNotFoundException}), permettendo 
    una gestione strutturata degli errori nei vari layer.

    \begin{figure} [h]
        \centering
        \includegraphics[width=1\linewidth]{img/package_exceptions.png}
        \caption{Exceptions Package}
    \end{figure}
   
\end{itemize}

Le dipendenze seguono una direzione controllata: i Controller dipendono dai Service, i Service dipendono da Domain e DAO, mentre il Domain Model non dipende dagli altri layer. Le eccezioni sono condivise tra i layer per rappresentare condizioni di errore applicativo.

\subsection{Class Diagrams}
In questa sezione viene illustrata la struttura delle classi, evidenziando le relazioni tra le entità e l'applicazione dei design pattern.

\subsubsection{Domain Model}
Il diagramma delle classi del Domain Model descrive la logica di business alla base dell'applicazione.
Come si è accennato, le classi sono state suddivise in 3 sotto-package all'interno del package Domain Model:
\begin{enumerate}
    \item \textbf{Events (Pattern Observer)}
    Questo package implementa il pattern Observer per gestire la propagazione dei cambiamenti di stato all'interno del Domain Model, assicurando che quando avviene un'azione (es. una spesa viene creata), le altre entità interessate (es. i saldi dei membri) vengano aggiornate automaticamente.
    \begin{itemize}
        \item \textbf{Subject (Classe Astratta)}: Definisce il contratto per le entità che possono generare eventi (come Group, Expense, Settlement). Gestisce una lista transient di observer e fornisce metodi per l'aggancio (attach) e la notifica (notifyObservers).
        
        \item \textbf{Observer (Interfaccia)}: Definita per le entità che devono reagire ai cambiamenti. Nel sistema, la classe Membership implementa questa interfaccia per aggiornare il proprio Balance in risposta agli eventi di dominio.
        
        \item \textbf{DomainEvent (Value Object)}: Incapsula i dettagli di un cambiamento di stato, inclusi l'identificativo della sorgente (sourceId), il timestamp, l'utente che ha scatenato l'azione (triggeredBy) e un payload flessibile sotto forma di mappa.
        
        \item \textbf{EventType (Enumeration)}: Cataloga in modo esaustivo gli eventi possibili, distinguendo tra operazioni amministrative (es. MEMBER\_JOINED), contabili (EXPENSE\_CREATED) e di conguaglio (SETTLEMENT\_CONFIRMED)
    \end{itemize}

    \item \textbf{Registry (Gestione Utenti e Gruppi)}
    \begin{itemize}
        \item \textbf{User (Entity)}: Rappresenta l'attore principale del sistema, identificato univocamente da email e dotato di logica per la verifica delle credenziali.
        
        \item \textbf{Group (Entity, Subject)}: L'entità centrale che aggrega membri, spese e saldi. Gestisce i codici di invito e lo stato di attività.
        Estende Subject per notificare modifiche alla sua struttura.
        
        \item Membership (Entity, Observer): Classe associativa che lega un User e un Group. Definisce il ruolo (ADMIN, MEMBER) e lo stato (ACTIVE, WAITING\_ACCEPTANCE, REMOVED). Implementa Observer per ricalcolare i debiti/crediti ogni volta che una spesa viene aggiunta o modificata nel gruppo di appartenenza.
    \end{itemize}
    
    \item \textbf{Accounting (Contabilità)}
    \begin{itemize}
        \item \textbf{Expense (Entity, Subject)}: Modella una spesa sostenuta da un membro (payer), include dettagli come l'importo (amount), la categoria e la data. Essendo un Subject, notifica gli osservatori (le Membership) affinché possano aggiornare i propri saldi netti.
        
        \item \textbf{ExpenseParticipant (Entity)}: Definisce quanto ogni beneficiario deve per una specifica spesa. Esiste in una relazione di composizione con Expense.
        
        \item \textbf{Balance (Entity)}: Ogni Membership ha un proprio Balance che traccia il debito/credito netto (netBalance) in tempo reale. Fornisce metodi per l'incremento o decremento del saldo e per la verifica dello stato di pareggio (isSettled).
        
        \item \textbf{Settlement (Entity, Subject)}: Rappresenta un'operazione di rimborso tra due membri (payer e receiver) per azzerare un debito. Include una gestione degli stati tramite PaymentStatus (PENDING, COMPLETED, REJECTED).
    \end{itemize}
\end{enumerate}

\begin{figure} [H]
    \centering
    \includegraphics[width=1\linewidth]{img/class_diagram_domain.png}
    \caption{Domain Model Class Diagram}
\end{figure}

\paragraph{Relazioni e Vincoli di Integrità}
Il diagramma evidenzia legami strutturali forti che guidano la persistenza e il ciclo di vita degli oggetti:
\begin{itemize}
    \item \textbf{Composizione}: Group esercita una composizione (1:N) su Membership, Expense e Settlement, indicando che queste entità non hanno ragione di esistere al di fuori del contesto del gruppo.
    Ogni Membership ha esattamente un Balance associato (1:1).
    
    \item \textbf{Associazioni}: Un User può avere più Membership (partecipare a più gruppi), mentre una Expense ha un singolo payer (Membership) ma molti participants. Le spese e i pareggi puntano a istanze di Membership per identificare gli attori finanziari coinvolti, garantendo l'integrità referenziale all'interno del database.
\end{itemize}

\subsubsection{ORM}
Il diagramma delle classi dell’ORM descrive il livello di persistenza del sistema, responsabile della traduzione tra oggetti del Domain Model e dati memorizzati nel database relazionale.
L'accesso ai dati è organizzato secondo il pattern Data Access Object (DAO), che incapsula i dettagli delle query SQL fornendo un'interfaccia orientata agli oggetti al Service Layer.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{img/class_diagram_orm.png}
    \caption{ORM Class Diagram}
    \label{fig:classdiagramORM}
\end{figure}

\paragraph{Componenti principali:}
\begin{enumerate}
    \item \textbf{ConnectionManager}
    
    La gestione delle connessioni al database è modellata tramite la classe \texttt{ConnectionManager}, rappresentata come Singleton. Essa fornisce l’accesso alla connessione JDBC e i metodi per la gestione delle transazioni: \texttt{beginTransaction()}, \texttt{commit()} e \texttt{rollback()}.
    Tutte le classi DAO convergono verso il \texttt{ConnectionManager}, da cui ottengono l'oggetto \texttt{Connection} necessario per eseguire le operazioni di persistenza.

    \item \textbf{Concrete DAOs}
    
    Per ciascuna entità principale del dominio è previsto un DAO dedicato (\texttt{UserDAO}, \texttt{GroupDAO}, \texttt{MembershipDAO}, \texttt{ExpenseDAO}, \texttt{BalanceDAO}, \texttt{SettlementDAO}). Ogni DAO espone metodi per il salvataggio, l'aggiornamento e il recupero delle entità. 
    Come evidenziato nel diagramma (Figura \ref{fig:classdiagramORM}), i DAO includono metodi specifici per il dominio, quali \texttt{findByInviteCode} in \texttt{GroupDAO }o \texttt{findByGroup} in \texttt{ExpenseDAO} per recuperare le spese di un contesto specifico.

    I DAO hanno la responsabilità architetturale di istanziare gli oggetti del Domain Model (\texttt{User, Group,} ecc.), mappando i risultati delle query (\texttt{ResultSet}) in oggetti Java utilizzabili dai layer superiori.
\end{enumerate}

\paragraph{Gestione delle eccezioni}
I DAO intercettano le eccezioni di basso livello (SQLException) e le incapsulano in \texttt{DAOException}.  
In questo modo i layer superiori rimangono indipendenti dai dettagli della tecnologia di persistenza e possono gestire gli errori a un livello più astratto.


\subsubsection{Service Layer}
Il Service Layer rappresenta il nucleo funzionale dell’applicazione.
Le classi di questo livello orchestrano interi casi d’uso coordinando entità di dominio e componenti di persistenza.
Ogni classe di servizio rappresenta un’area funzionale ben definita del sistema:
\begin{itemize}
    \item \textbf{UserService}: gestisce registrazione, autenticazione e aggiornamento del profilo utente, utilizzando il \texttt{PasswordHasher} per la sicurezza delle credenziali.
    \item \textbf{GroupService}: gestisce la creazione dei gruppi, la generazione dei codici invito, l’ingresso nei gruppi e le operazioni amministrative sui membri.
    \item \textbf{ExpenseService}: coordina la creazione, modifica e cancellazione delle spese, assicurando la coerenza dei dati contabili.
    \item \textbf{SettlementService}: gestisce i rimborsi tra membri e la loro conferma.
    \item \textbf{BalanceService}: fornisce funzionalità di consultazione dei saldi e di ottimizzazione dei debiti.
\end{itemize}   

Oltre a coordinare operazioni che coinvolgono più entità e più DAO all'interno della stessa operazione logica, 
al Service Layer sono assegnate due responsabilità architetturali fondamentali:

\textbf{1. Gestione transazionale:} I Service definiscono i confini delle transazioni atomiche interagendo con il 
\texttt{ConnectionManager}, garantiscono che operazioni che coinvolgono scritture multiple su diversi DAO vengano 
confermate (commit) o annullate (rollback) in blocco, preservando l'integrità del database.

\textbf{2. Ciclo di vita degli Observer:} Poiché le liste di Observer associate ai Subject (Expense, Settlement, Group)
non vengono persistite nel database, prima di eseguire un'operazione che comporta un cambiamento di stato, 
il Service Layer ricostruisce dinamicamente (\textbf{wiring}) queste dipendenze a runtime caricando i membri interessati e 
agganciandoli al Subject.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{img/class_diagram_service.png}
    \caption{Service Layer Class Diagram}
    \label{fig:servicediagram}
\end{figure}

\paragraph{Applicazione dello Strategy Pattern per l'Ottimizzazione dei Debiti}
Quando gli utenti registrano numerose spese incrociate, il sistema deve capire chi deve pagare chi, cercando di ridurre al minimo il numero di bonifici necessari per azzerare i debiti di tutti.
Per risolvere questo problema, è stato implementato un algoritmo di ottimizzazione dei debiti all'interno del \texttt{BalanceService} che delega la complessa logica di calcolo a un componente esterno, 
sfruttando il pattern comportamentale \textbf{Strategy}.
Il pattern Strategy permette di separare "chi gestisce i dati" da "chi esegue i calcoli", strutturando la soluzione in tre elementi chiave:
\begin{enumerate}
    \item \textbf{Il Contesto (BalanceService)}: 
    Agisce come un coordinatore, si occupa di recuperare i saldi aggiornati dal database e passarli all'algoritmo di calcolo, senza preoccuparsi di come questo funzioni internamente.

    \item \textbf{L'Interfaccia (BalanceStrategy)}: 
    Definisce il contratto standard di comunicazione, espone un unico metodo, optimize, che prende in input la mappa dei saldi dei membri \texttt{(Map<Membership, BigDecimal>)} e garantisce di restituire una lista di transazioni da effettuare \texttt{(List<Settlement>)}.

    \item \textbf{La Strategia Concreta (MinTransactionsStrategy)}: 
    È la classe che implementa fisicamente l'interfaccia e contiene il vero e proprio algoritmo matematico progettato per minimizzare gli scambi di denaro.

\end{enumerate}
Questa architettura rispetta il principio \textbf{Open/Closed}:
qualora in futuro si rendesse necessario introdurre un nuovo criterio per il calcolo dei rimborsi 
(ad esempio, un algoritmo che arrotonda le cifre per agevolare lo scambio di contanti), 
sarà sufficiente sviluppare una nuova classe che implementi \texttt{BalanceStrategy}, 
lasciando invariato il codice del \texttt{BalanceService}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{img/class_diagram_controller.png}
    \caption{Controller Layer Class Diagram}
    \label{fig:controllerdiagram}
\end{figure}

\subsubsection{Controller Layer}
Il Controller Layer rappresenta il punto di accesso ai casi d’uso dal lato CLI. 
I Controller (\texttt{AuthController}, \texttt{GroupController}, \texttt{ExpenseController}, \texttt{BalanceController}) non contengono business logic complessa, ma svolgono un ruolo di coordinamento tra interfaccia utente e service: 
ricevono le richieste dell’utente, ne verificano la validità formale e delegano l’elaborazione ai servizi appropriati.

Per supportare il funzionamento dei Controller, come illustrato in Figura \ref{fig:controllerdiagram}, il sistema include due componenti infrastrutturali modellati come Singleton, scelti per garantire un punto di accesso globale controllato:
\begin{itemize}
\item \textbf{\texttt{UserSession}}: gestisce il contesto e lo stato globale dell'applicazione. 
Conserva i riferimenti all'utente attualmente autenticato (\texttt{currentUser}) e al gruppo selezionato (\texttt{currentGroup}). 
Questo approccio centralizzato evita di dover passare continuamente questi parametri a ogni singola invocazione dei metodi del Controller o del Service.

\item \textbf{\texttt{NavigationManager}}: implementa l'interfaccia \texttt{Navigator} e centralizza il flusso di transizione tra i menu della CLI. 
Questa struttura applica il \textit{Dependency Inversion Principle}: i controller dipendono unicamente dall'astrazione e non dall'implementazione concreta, garantendo il totale disaccoppiamento della logica applicativa dall'input/output su console.
Questo è fondamentale per consentire l'esecuzione isolata dei test automatizzati (questo aspetto verrà approfondito nella \textbf{Sezione \ref{sec:testing_e2e}}).
\end{itemize}


\subsection{Database}
La progettazione del database è stata effettuata in continuità
con il Domain Model, garantendo allineamento tra entità software
e strutture relazionali. Le relazioni, le cardinalità e i vincoli
di integrità presenti nel modello ER riflettono quelli definiti
nel diagramma delle classi.

\subsubsection{Modello ER}
\begin{figure} [h]
    \centering
    \includegraphics[width=0.95\linewidth]{img/ER_diagram.png}
    \caption{Modello ER}
\end{figure}

\newpage
\subsubsection{Schema Relazionale}
Dalla traduzione del modello ER si ottiene il seguente schema relazionale.
Le chiavi primarie (PK) sono sottolineate, mentre le chiavi esterne (FK) mantengono il nome dell'attributo referenziato.

\begin{flushleft}
\textbf{User} (\underline{user\_id}, email, full\_name, password)
\medskip

\textbf{Group} (\underline{group\_id}, name, description, currency,
invite\_code, invite\_code\_expiry\_date, creation\_date,
created\_by\_user\_id, is\_active)
\medskip

\textbf{Membership} (\underline{membership\_id}, user\_id,
group\_id, role, status)
\medskip

\textbf{Expense} (\underline{expense\_id}, group\_id,
payer\_membership\_id, created\_by\_membership, amount,
description, category, expense\_date, last\_modified\_date,
is\_deleted)
\medskip

\textbf{ExpenseParticipant} (\underline{participant\_id},
expense\_id, beneficiary\_membership\_id, share\_amount)
\medskip

\textbf{Balance} (\underline{balance\_id}, membership\_id,
net\_balance, last\_updated)
\medskip

\textbf{Settlement} (\underline{settlement\_id}, group\_id,
payer\_membership\_id, receiver\_membership\_id, amount,
settlement\_date, status)

\end{flushleft}

