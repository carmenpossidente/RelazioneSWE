\section{Implementazione}

L’implementazione del sistema è stata realizzata seguendo le scelte architetturali 
definite in fase di progettazione, con l’obiettivo di mantenere una chiara separazione 
delle responsabilità tra i diversi livelli applicativi.

\subsection{Domain Model}
Il Domain Model è stato implementato in Java ponendo particolare attenzione
alla protezione delle invarianti di classe, all'uso corretto dei tipi per i dati
monetari e all'integrazione con il pattern Observer tramite una lista di observer
non persistita.

\subsubsection{Protezione delle invarianti nei costruttori}

Ogni entità del dominio valida i propri invarianti direttamente nel costruttore,
rendendo impossibile la creazione di oggetti in uno stato inconsistente. La
filosofia adottata è quella del \textit{fail-fast}: se i dati forniti violano le regole di
business, viene lanciata immediatamente un'eccezione prima che l'oggetto
venga allocato.

La classe \texttt{User} verifica che email, nome e hash della password non siano
nulli o vuoti tramite controlli espliciti; \texttt{Membership} richiede che 
\texttt{user}, \texttt{group} e \texttt{role} siano tutti non-null, sempre tramite 
controlli espliciti; \texttt{Group} lancia \texttt{IllegalArgumentException} se nome o valuta sono
assenti. L'invariante più critica si trova in \texttt{Balance}: il campo
\texttt{membership} è dichiarato \texttt{final} e protetto con \texttt{Objects.requireNonNull()},
rendendo strutturalmente impossibile avere un saldo orfano. Il campo
\texttt{netBalance} viene inizializzato a zero con scala fissa a due cifre decimali,
garantendo la consistenza monetaria fin dalla costruzione:

\begin{lstlisting}[language=Java, caption={Invarianti del costruttore di Balance}]
public Balance(Long balanceId, Membership membership) {
    this.balanceId = balanceId;
    this.membership = Objects.requireNonNull(membership);
    this.netBalance = BigDecimal.ZERO.setScale(2, RoundingMode.HALF_UP);
    this.lastUpdated = LocalDateTime.now();
}
\end{lstlisting}

In \texttt{Expense}, la validazione dell'importo è incapsulata nel metodo privato
\texttt{setAmount()}, che viene invocato sia nel costruttore sia in
\texttt{modifyDetails()}: in questo modo la regola è espressa in un unico punto
e non può essere aggirata nemmeno durante un aggiornamento successivo.
Analogamente, \texttt{Settlement} verifica nel costruttore che \texttt{payer} e
\texttt{receiver} siano membri distinti, proteggendo il sistema da auto-pagamenti:

\begin{lstlisting}[language=Java, caption={Validazione singola di importo in Expense e verifica di identita in Settlement}]
// In Expense: metodo privato richiamato nel costruttore e in modifyDetails()
private void setAmount(BigDecimal amount) {
    if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
        throw new DomainException("Amount must be positive.");
    }
    this.amount = amount;
}

// In Settlement: controllo di identita' nel costruttore
if (payer.equals(receiver)) {
    throw new IllegalArgumentException("Payer and receiver must be different");
}
\end{lstlisting}

\subsubsection{Lista di Observer non persistita e wiring a runtime}
\label{sec:observer_wiring}
La classe astratta \texttt{Subject} mantiene la lista degli Observer come campo
d'istanza ordinario, senza alcuna marcatura speciale nel codice Java. L'assenza
di persistenza di questo campo è una conseguenza architettonica deliberata: il
Data Access Layer ricostruisce le entità a partire dai dati relazionali, e nessuna
query SQL carica relazioni di tipo Observer. La lista è pertanto
\textit{logicamente transient}, una caratteristica architetturale che prescinde dall'uso della
keyword \texttt{transient} di Java, la quale non è necessaria in assenza di
serializzazione.

La conseguenza pratica è che ogni entità \texttt{Subject} (\texttt{Group},
\texttt{Expense}, \texttt{Settlement}) viene restituita dal DAO con la lista degli
observer vuota. Il Service Layer si fa carico di ricollegare gli observer prima di
invocare qualsiasi operazione che generi eventi, attraverso la procedura di wiring
descritta nella Sezione~\ref{sec:service_wiring}.

La classe \texttt{Subject} adotta inoltre una misura difensiva nella notifica:
\texttt{notifyObservers()} opera su una copia della lista per evitare
eccezioni di tipo \texttt{ConcurrentModificationException} nel caso in cui 
un observer modificasse la lista durante la propagazione dell'evento:

\begin{lstlisting}[language=Java, caption={Notifica sicura degli observer in Subject}]
protected void notifyObservers(DomainEvent event) {
    if (event == null) return;
    List<Observer> observersCopy = new ArrayList<>(observers);
    for (Observer observer : observersCopy) {
        try {
            observer.onDomainEvent(event);
        } catch (Exception e) {
            // Continua con gli altri observer
        }
    }
}
\end{lstlisting}

\subsubsection{Soft delete in Expense}

La cancellazione delle spese è implementata come \textit{soft delete}: il metodo
\texttt{markAsDeleted(Membership deletedBy)} imposta il flag booleano
\texttt{isDeleted = true} sull'oggetto e aggiorna \texttt{lastModifiedDate}, senza
rimuovere alcuna riga dal database. Questo approccio preserva la storia contabile
del gruppo e consente di tracciare chi ha eliminato la spesa e quando.

Prima di procedere, il metodo verifica l'autorizzazione tramite
\texttt{canBeDeletedBy()}: solo l'admin del gruppo o chi ha creato la spesa può
eliminarla. Se la spesa è già stata eliminata, viene sollevata una
\texttt{IllegalStateException} per evitare cancellazioni doppie. Successivamente
viene generato e propagato un \texttt{DomainEvent} di tipo
\texttt{EXPENSE\_DELETED} agli Observer collegati; la notifica raggiunge le
\texttt{Membership} agganciate, che la utilizzano per simulare l'invio di una
comunicazione all'utente tramite logging. Le rettifiche contabili sui
\texttt{Balance} sono invece gestite transazionalmente dal Service Layer, che
dopo la notifica aggiorna i saldi tramite \texttt{BalanceDAO}.

\begin{lstlisting}[language=Java, caption={Soft delete in Expense}]
public void markAsDeleted(Membership deletedBy) {
    if (!canBeDeletedBy(deletedBy)) {
        throw new UnauthorizedException(
            "Only admin or creator can delete the expense");
    }
    if (isDeleted) {
        throw new IllegalStateException("Expense already deleted");
    }
    this.isDeleted = true;
    touch(); // aggiorna lastModifiedDate
    notifyObservers(createEvent(
        EventType.EXPENSE_DELETED,
        deletedBy,
        Map.of("amount", amount, "description", description)
    ));
}
\end{lstlisting}

A livello di persistenza, il metodo \texttt{findByGroup()} in \texttt{ExpenseDAO}
filtra automaticamente le spese eliminate attraverso la clausola
\texttt{WHERE is\_deleted = FALSE}, rendendo la cancellazione logica trasparente
per i layer superiori senza alcun intervento aggiuntivo del Service Layer.

\subsubsection{Uso di BigDecimal per i calcoli monetari}

Tutti i campi e le operazioni che coinvolgono importi monetari utilizzano
\texttt{java.math.BigDecimal} invece di \texttt{double} o \texttt{float}. La scelta
è motivata dalla necessità di evitare gli errori di rappresentazione in virgola
mobile tipici dei tipi primitivi: una somma come \texttt{0.1 + 0.2} in
\texttt{double} produce \texttt{0.30000000000000004}, un risultato inaccettabile in
contesti finanziari.

\texttt{BigDecimal} garantisce precisione decimale arbitraria e operazioni di
arrotondamento configurabili. Nel sistema, il modo di arrotondamento standard
adottato è \texttt{RoundingMode.HALF\_UP} con scala fissa a 2 cifre decimali.
Questo arrotondamento è applicato sistematicamente nei metodi \texttt{increment()},
\texttt{decrement()} e \texttt{apply()} di \texttt{Balance}, come mostra il seguente
estratto:

\begin{lstlisting}[language=Java, caption={Arrotondamento sistematico in Balance.increment() e decrement()}]
public void increment(BigDecimal amount) {
    validateAmount(amount);
    netBalance = netBalance.add(amount).setScale(2, RoundingMode.HALF_UP);
    touch();
}

public void decrement(BigDecimal amount) {
    validateAmount(amount);
    netBalance = netBalance.subtract(amount).setScale(2, RoundingMode.HALF_UP);
    touch();
}
\end{lstlisting}

Il medesimo criterio si applica nel calcolo della quota per partecipante in
\texttt{ExpenseDAO.create()}, dove si usa \texttt{BigDecimal.divide()} con scala e
\texttt{RoundingMode} espliciti, e nella classe \texttt{MinTransactionsStrategy},
dove il confronto tra importi viene effettuato sempre con \texttt{compareTo()}
invece dell'operatore \texttt{==}, rispettando la semantica di \texttt{BigDecimal}.

\subsection{Data Access Layer}
Il Data Access Layer gestisce la persistenza del sistema attraverso il pattern
DAO (Data Access Object). Ogni classe DAO incapsula le query SQL relative a
una specifica entità di dominio, esponendo al Service Layer un'interfaccia
orientata agli oggetti che nasconde completamente i dettagli del database
relazionale sottostante.

\subsubsection{ConnectionManager: Singleton e gestione della connessione JDBC}

La classe \texttt{ConnectionManager} è implementata come Singleton con
inizializzazione \textit{eager}: l'istanza unica viene creata al momento del
caricamento della classe tramite un campo \texttt{static final}, garantendo
thread-safety senza necessità di sincronizzazione esplicita.

\begin{lstlisting}[language=Java, caption={Singleton con inizializzazione eager in ConnectionManager}]
public class ConnectionManager {

    private static final ConnectionManager INSTANCE = new ConnectionManager();
    private Connection connection;

    private ConnectionManager() {
        try {
            connection = DriverManager.getConnection(
                "jdbc:h2:mem:splitmanager;DB_CLOSE_DELAY=-1;"
                + "INIT=RUNSCRIPT FROM 'classpath:schema.sql'",
                "sa", ""
            );
            connection.setAutoCommit(false);
        } catch (SQLException e) {
            throw new RuntimeException("Failed to connect to database", e);
        }
    }

    public Connection getConnection() { return connection; }

    public static ConnectionManager getInstance() { return INSTANCE; }

    public void beginTransaction() throws SQLException {
        connection.setAutoCommit(false);
    }
    public void commit() throws SQLException {
        connection.commit();
        connection.setAutoCommit(true);
    }
    public void rollback() throws SQLException {
        connection.rollback();
        connection.setAutoCommit(true);
    }
}
\end{lstlisting}

La connessione è diretta a un database H2 in-memory, scelto per semplicità di
setup e velocità di esecuzione nei test. Il parametro \texttt{DB\_CLOSE\_DELAY=-1}
mantiene il database attivo per tutta la durata del processo JVM. L'autocommit
è disabilitato fin dal costruttore, cosicché ogni operazione si colloca di default
in una transazione controllata dal Service Layer. I metodi
\texttt{beginTransaction()}, \texttt{commit()} e \texttt{rollback()} permettono al
Service di gestire i confini transazionali senza accedere direttamente all'oggetto
\texttt{Connection}.

Tutti i DAO ottengono la connessione chiamando 
\texttt{getInstance().getConnection()} sul Singleton 
\texttt{ConnectionManager}, garantendo che l'intera
applicazione condivida un unico oggetto \texttt{Connection} e che tutte le
operazioni eseguite nell'ambito di un caso d'uso siano parte della stessa
transazione.

\subsubsection{Struttura comune dei DAO e mapping ResultSet -- entità}

Ogni DAO segue una struttura uniforme composta da tre responsabilità principali:
le operazioni CRUD, la costruzione delle query SQL tramite
\texttt{PreparedStatement}, e il mapping dei risultati da \texttt{ResultSet} a
oggetti di dominio.

Il mapping è centralizzato in un metodo privato \texttt{mapResultSetToX()} per
ciascun DAO, che ricostruisce l'oggetto di dominio leggendo le colonne del
\texttt{ResultSet} per nome. Questo approccio isola il codice di conversione in un
unico punto, facilitando la manutenzione in caso di modifiche allo schema.

Per le entità con relazioni, come \texttt{Membership} che aggrega \texttt{User} e
\texttt{Group}, il DAO utilizza JOIN nella query SQL ed esegue il mapping annidato
all'interno dello stesso metodo, ricostruendo l'oggetto completo in un'unica
passata sul \texttt{ResultSet}. Il metodo \texttt{mapResultSetToMembership()} in
\texttt{MembershipDAO} illustra la complessità tipica di questo mapping: costruisce
prima un oggetto \texttt{User} e un oggetto \texttt{Group} a partire dalle colonne
della JOIN, gestisce la conversione del campo nullable
\texttt{invite\_code\_expiry\_date} da \texttt{Timestamp} a \texttt{LocalDateTime},
converte il ruolo da stringa a enum tramite \texttt{Role.valueOf()}, e infine
assembla la \texttt{Membership} impostando lo stato corretto:

\begin{lstlisting}[language=Java, caption={Mapping annidato in MembershipDAO.mapResultSetToMembership()}]
private Membership mapResultSetToMembership(ResultSet rs) throws SQLException {
    User user = new User(
        rs.getLong("user_id"),
        rs.getString("email"),
        rs.getString("full_name"),
        rs.getString("password_hash")
    );

    Group group = new Group(
        rs.getLong("group_id"),
        rs.getString("name"),
        rs.getString("currency")
    );
    group.setDescription(rs.getString("description"));
    group.setInviteCode(rs.getString("invite_code"));

    // Conversione nullable Timestamp -> LocalDateTime
    Timestamp expiry = rs.getTimestamp("invite_code_expiry_date");
    if (expiry != null) {
        group.setInviteCodeExpiry(expiry.toLocalDateTime());
    }
    group.setActive(rs.getBoolean("is_active"));

    Membership membership = new Membership(
        rs.getLong("membership_id"),
        user,
        group,
        Role.valueOf(rs.getString("role"))
    );

    MembershipStatus status = MembershipStatus.valueOf(rs.getString("status"));
    membership.changeStatus(status);

    return membership;
}
\end{lstlisting}

Le operazioni di inserimento recuperano la chiave primaria autogenerata dal
database tramite \texttt{Statement.RETURN\_GENERATED\_KEYS} e
\texttt{stmt.getGeneratedKeys()}, assegnandola all'oggetto di dominio prima di
restituirlo al chiamante. In questo modo il Service Layer riceve sempre oggetti
completamente identificati senza dover eseguire una query aggiuntiva.

Infine, il \texttt{BalanceDAO} adotta un pattern di \textit{self-contained mapping}:
invece di dipendere da \texttt{MembershipDAO} per ricostruire le
\texttt{Membership} associate ai saldi (il che creerebbe una dipendenza circolare),
replica localmente il codice di mapping necessario. La duplicazione è consapevole
e documentata, ed è preferita rispetto all'introduzione di un ciclo di dipendenze
tra DAO.

\subsubsection{Gestione SQLException e traduzione in DAOException}

Ogni metodo DAO avvolge le proprie operazioni SQL in un blocco
\texttt{try-catch} che intercetta le eccezioni \texttt{SQLException} di basso
livello e le converte in \texttt{DAOException}, un'eccezione unchecked definita nel
package \texttt{exception}. Questa traduzione ha una funzione architetturale
precisa: isola il Service Layer dai dettagli dell'infrastruttura di persistenza,
consentendogli di gestire gli errori a un livello di astrazione più alto senza dover
conoscere i codici di errore JDBC o le eccezioni checked di \texttt{java.sql}.
Inoltre, la \texttt{SQLException} originale viene passata al costruttore della 
\texttt{DAOException} come causa, preservando così la traccia dello stack 
dell'errore originario.

Il metodo \texttt{save()} di \texttt{UserDAO} illustra il pattern: la chiamata a
\texttt{stmt.executeUpdate()} è racchiusa in un \texttt{try-with-resources} che
chiude automaticamente il \texttt{PreparedStatement} al termine, mentre
l'eventuale \texttt{SQLException} viene catturata e rilasciata come
\texttt{DAOException} con un messaggio descrittivo e la causa originale
incapsulata nel campo \texttt{cause}:

\begin{lstlisting}[language=Java, caption={Traduzione di SQLException in DAOException in UserDAO.save()}]
public User save(User user) {
    String sql = "INSERT INTO users (email, full_name, password_hash) "
               + "VALUES (?, ?, ?)";
    try (PreparedStatement stmt = connection.prepareStatement(
            sql, Statement.RETURN_GENERATED_KEYS)) {

        stmt.setString(1, user.getEmail());
        stmt.setString(2, user.getFullName());
        stmt.setString(3, user.getPasswordHash());

        int affectedRows = stmt.executeUpdate();
        if (affectedRows == 0) {
            throw new DAOException("Creating user failed", null);
        }

        try (ResultSet keys = stmt.getGeneratedKeys()) {
            if (keys.next()) {
                Long userId = keys.getLong(1);
                return new User(userId, user.getEmail(),
                                user.getFullName(), user.getPasswordHash());
            } else {
                throw new DAOException("No ID obtained for new user", null);
            }
        }
    } catch (SQLException e) {
        throw new DAOException("Error saving user", e);
    }
}
\end{lstlisting}

Oltre alla semplice conversione, alcuni DAO implementano logiche di 
persistenza più avanzate. Il \texttt{BalanceDAO}, ad esempio, gestisce un caso 
particolare: il metodo \texttt{save()} tenta prima un \texttt{INSERT} e, se riceve 
un errore di constraint violation (indicato dallo SQL state \texttt{23505} per H2 
o dall'error code \texttt{1062} per MySQL), interpreta l'eccezione e si comporta 
come un \textit{upsert}, delegando automaticamente l'operazione a \texttt{update()}.

\begin{lstlisting}[language=Java, caption={Logica di upsert in BalanceDAO.save()}]
public Balance save(Balance balance) {
    String sql = "INSERT INTO balances (membership_id, net_balance, last_updated) VALUES (?, ?, ?)";
    try (PreparedStatement stmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
        stmt.setLong(1, balance.getMembership().getMembershipId());
        stmt.setBigDecimal(2, balance.getNetBalance());
        stmt.setTimestamp(3, Timestamp.valueOf(LocalDateTime.now()));
            
        int affectedRows = stmt.executeUpdate();
        if (affectedRows == 0) {
            throw new DAOException("Creating balance failed", null);
        }
            
        try (ResultSet keys = stmt.getGeneratedKeys()) {
            if (keys.next()) {
                Long balanceId = keys.getLong(1);
                balance.setBalanceId(balanceId);
            }
        }
            
        return balance;
    } catch (SQLException e) {
        if (e.getErrorCode() == 1062 || "23505".equals(e.getSQLState())) {
            return update(balance);
        }
        throw new DAOException("Error saving balance", e);
    }
}
\end{lstlisting}

Questo meccanismo semplifica la logica del Service Layer, che può invocare
\texttt{balanceDAO.save()} senza preoccuparsi se il record esista già o meno, 
delegando al DAO la responsabilità di eseguire l'operazione corretta.

\subsection{Service Layer}
Il Service Layer funge da collante tra la logica di business pura (Domain) e l'accesso ai dati (DAO).
Di seguito si analizzano i dettagli implementativi più rilevanti di questo livello.

\subsubsection{Gestione Delle Transazioni}
Alla base della gestione transazionale c'è la classe Singleton \texttt{ConnectionManager} del livello DAO, 
che gestisce l'unica connessione attiva verso il database H2 mettendo a disposizione i metodi \texttt{beginTransaction()}, 
\texttt{commit()} e \texttt{rollback()}. 

La responsabilità di invocare questi metodi spetta alle classi Service che, 
essendo a conoscenza dell'intero caso d'uso, decidono i confini della transazione coordinando le chiamate a più DAO. 
Per farlo in modo sicuro, il Service sfrutta l'istanza del \texttt{ConnectionManager} all'interno di un costrutto \texttt{try-catch}, 
orchestrando così il \texttt{commit} in caso di successo o il \texttt{rollback} in caso di errore.

Il flusso standard di una transazione gestita dal Service funziona in questo modo:
\begin{enumerate}
    \item Il Service ottiene la connessione dal \texttt{ConnectionManager} e invoca \texttt{beginTransaction()} prima di eseguire qualsiasi operazione che modifichi lo stato del database.
    \item Il Service chiama i vari DAO necessari per compiere l'azione richiesta dall'utente.
    \item Se tutte le operazioni sui DAO vanno a buon fine, il Service invoca \texttt{commit()} per rendere permanenti le modifiche. 
    \item Se si verifica un'eccezione durante l'esecuzione delle operazioni sui DAO (ad esempio per errori SQL o vincoli violati), 
    il Service cattura l'eccezione, invoca \texttt{rollback()} per annullare tutte le modifiche parziali e propaga l'errore incapsulandolo 
    in una \texttt{DAOException}. Questo garantisce l'integrità dei dati e isola i livelli superiori dai dettagli infrastrutturali del database.  
\end{enumerate}

Nel seguente snippet, tratto da \texttt{ExpenseService}, è visibile la gestione transazionale durante la creazione di una nuova spesa:

\begin{lstlisting}[language=Java, caption={Gestione della transazione nel metodo addExpense di ExpenseService}]
ConnectionManager connMgr = ConnectionManager.getInstance();

try {
    connMgr.beginTransaction(); // Disabilita l'autocommit

    // [Omissis: validazione e caricamento entita']

    Expense expense = expenseDAO.create(
        groupId, payerMembershipId, amount, 
        description, category, participantIds
    );

    // [Omissis: Wiring degli Observer e chiamate a balanceDAO.update()]

    connMgr.commit(); // Conferma le modifiche in blocco
    return expense;

} catch (Exception e) {
    try {
        connMgr.rollback(); // Annulla tutte le modifiche parziali
    } catch (SQLException ex) {
        throw new DAOException("Error during transaction rollback", ex);
    }

    if (e instanceof DomainException) {
        throw (DomainException) e;
    }
    throw new DomainException("Error creating expense", e);
}
\end{lstlisting}


\subsubsection{Wiring Dinamico degli Observer}
\label{sec:service_wiring}
Il pattern Observer viene utilizzato per fare in modo che determinati eventi aggiornino in automatico altre entità. 
Le classi Group, Expense e Settlement fungono da \textbf{Subject}, mentre la classe Membership agisce come \textbf{Observer}.

All'interno della classe astratta \texttt{Subject}, la lista degli Observer 
non viene persistita nel database (come discusso nella Sezione~\ref{sec:observer_wiring}).
Di conseguenza, quando un'entità come una \texttt{Expense} viene letta dal database, non sa chi siano i suoi Observer,
è responsabilità esclusiva del Service Layer ricreare questi collegamenti al volo (operazione definita appunto "wiring").
Dunque, quando deve eseguire un'operazione che scaturirà un evento (es.\ creazione di una nuova spesa), 
il Service esegue questi passaggi precisi:
\begin{enumerate}
    \item Interroga il database tramite i DAO per ottenere l'oggetto principale (ad esempio l'Expense).
    \item Carica tutte le entità Observer correlate (tutte le Membership coinvolte).
    \item Effettua il wiring, ovvero collega manualmente gli oggetti in memoria chiamando il metodo \texttt{attach()} sul Subject per ogni Observer trovato (es.\ texttt{expense.attach(membership)}).
    \item Esegue la modifica richiesta. A questo punto, il Subject invoca internamente \texttt{notifyObservers()}; le Membership collegate ricevono la notifica in tempo reale e aggiornano i propri saldi.
    \item Una volta che gli Observer hanno aggiornato il loro stato in memoria, il Service utilizza i DAO appropriati (es.\ BalanceDAO) per salvare le modifiche definitive sul database.
\end{enumerate}

\begin{lstlisting}[language=Java, caption={Implementazione del Wiring dinamico in ExpenseService}]
// Carica tutti i membri del gruppo dal database
List<Membership> allMembers = membershipDAO.findByGroup(groupId);

for (Membership member : allMembers) {
    expense.attach(member); // Effettua il Wiring
}


\end{lstlisting}
\paragraph{Gestione della memoria (Request Scope)}
Poiché il wiring viene effettuato dinamicamente, gli oggetti coinvolti hanno
un ciclo di vita limitato alla singola operazione applicativa (\textit{Request Scope}).
Il Service li carica dal database, li collega tramite \texttt{attach()},
esegue l’operazione richiesta e non mantiene riferimenti persistenti oltre
tale ambito, consentendo al sistema di liberarli automaticamente al termine
dell’elaborazione, riducendo così il rischio di memory leak.



\subsubsection{Ottimizzazione dei Debiti: Algoritmo Greedy}
L'algoritmo di ottimizzazione incapsulato in \texttt{MinTransactionsStrategy} implementa un approccio \textbf{greedy}. 

Il metodo \texttt{optimize()} riceve in ingresso la mappa dei saldi netti
(\texttt{Map<Membership, BigDecimal>}) e suddivide i membri in due insiemi:
\textbf{Debitors} (saldo negativo) e \textbf{Creditors} (saldo positivo),
utilizzando una classe di supporto interna chiamata \texttt{DebtorCredit}.
Le due liste vengono ordinate in ordine decrescente rispetto all'importo.
Successivamente, un ciclo \texttt{while} effettua un matching greedy tra
il debitore con debito maggiore e il creditore con credito maggiore,
creando un nuovo oggetto \texttt{Settlement} per l'importo minimo tra i due saldi
e aggiornando i residui fino all'azzeramento completo.

\begin{lstlisting}[language=Java, caption={Nucleo del matching Greedy in MinTransactionsStrategy}]
// Matching greedy (su liste precedentemente ordinate)
int i = 0; // Indice debitori
int j = 0; // Indice creditori

while (i < debtors.size() && j < creditors.size()) {
    DebtorCredit debtor = debtors.get(i);
    DebtorCredit creditor = creditors.get(j);

    // L'importo da trasferire e' il minimo tra debito e credito attuale
    BigDecimal settleAmount = debtor.amount.min(creditor.amount);

    // Registra la transazione da effettuare
    settlements.add(new Settlement(
        debtor.membership.getGroup(), debtor.membership, creditor.membership, settleAmount
    ));

    // Decurta l'importo appena saldato dai totali residui
    debtor.amount = debtor.amount.subtract(settleAmount);
    creditor.amount = creditor.amount.subtract(settleAmount);

    // Se il debito o il credito e' azzerato, si avanza con l'indice
    if (debtor.amount.compareTo(BigDecimal.ZERO) == 0) i++;
    if (creditor.amount.compareTo(BigDecimal.ZERO) == 0) j++;
}
\end{lstlisting}

Questa implementazione garantisce matematicamente che il numero di transazioni generate sia sempre al più $(N - 1)$, dove $(N)$ è il numero di membri coinvolti


\subsection{Controller Layer e CLI}

Il Controller Layer costituisce il punto di ingresso della logica applicativa, 
ricevendo gli input dall'interfaccia utente e coordinando le chiamate ai Service. 
Il sistema utilizza una \textbf{Command Line Interface (CLI)} come Presentation Layer.

L'architettura adottata separa nettamente questi due livelli, garantendo che:
\begin{itemize}
    \item I Controller contengano esclusivamente logica di coordinamento, 
    delegando ai Service le operazioni di business.
    \item La CLI gestisca solo aspetti di presentazione (menu, input/output), 
    senza conoscere dettagli implementativi dei Service o del Domain.
\end{itemize}

\subsubsection{Dependency Injection nei Controller}

Tutti i Controller ricevono le proprie dipendenze (Service, Session, Navigator) 
tramite costruttore, applicando il principio di \textbf{Dependency Injection}. 
Questo approccio offre numerosi vantaggi in termini di testabilità ed esplicitezza, 
garantendo inoltre l'immutabilità dello stato (le dipendenze sono dichiarate 
\texttt{final}):

\begin{lstlisting}[language=Java, caption={Dependency Injection nel costruttore di AuthController}]
public class AuthController {
    private final UserService userService;
    private final UserSession session;
    private final Navigator navigator;

    public AuthController(UserService userService, 
                          UserSession session, 
                          Navigator navigator) {
        if (userService == null || session == null || navigator == null) {
            throw new IllegalArgumentException("Dependencies cannot be null");
        }
        this.userService = userService;
        this.session = session;
        this.navigator = navigator;
    }
    // ... logica di coordinamento ...
}
\end{lstlisting}

Nel codice sopra, \texttt{AuthController} riceve tre dipendenze tramite costruttore:
\begin{itemize}
    \item \texttt{UserService}: per eseguire operazioni di autenticazione.
    \item \texttt{UserSession}: per mantenere lo stato della sessione corrente.
    \item \texttt{Navigator}: per gestire navigazione e feedback utente.
\end{itemize}

Il costruttore valida che nessuna dipendenza sia \texttt{null}, 
garantendo che il Controller sia sempre in uno stato consistente.

\subsubsection{Gestione dello Stato: UserSession Singleton}

Il mantenimento dello stato dell'utente autenticato è affidato alla classe 
\texttt{UserSession}, implementata seguendo il pattern creazionale \textbf{Singleton}. 
Questa specifica architettura prevede un costruttore privato, che impedisce la creazione 
diretta di istanze esterne tramite la keyword \texttt{new}. 

L'istanza unica viene invece allocata in memoria solo al primo accesso effettivo 
tramite il metodo \texttt{getInstance()}, sfruttando il meccanismo della \textit{lazy initialization} 
per ottimizzare il consumo di risorse. 
Tale approccio garantisce l'esistenza di un'unica istanza globale condivisa per 
l'intera esecuzione del programma: ciò permette ai vari Controller di accedere in 
qualsiasi momento ai dati dell'utente loggato e del gruppo correntemente selezionato, 
eliminando la necessità di propagare continuamente questi oggetti attraverso le firme 
dei metodi. 

Infine, la classe espone metodi di utility dedicati, come \texttt{isLoggedIn()} e 
\texttt{hasGroupSelected()}, che semplificano notevolmente i controlli condizionali 
all'interno dei layer superiori.

\begin{lstlisting}[language=Java, caption={Lazy initialization nel Singleton UserSession}]
public class UserSession {
    private static UserSession instance;
    private User currentUser;
    // ... altri campi ...

    private UserSession() {} // Costruttore privato

    public static UserSession getInstance() {
        if (instance == null) {
            instance = new UserSession(); // Istanziazione ritardata (Lazy)
        }
        return instance;
    }
    // ... getter e setter ...
}
\end{lstlisting}

\subsubsection{Dependency Inversion Principle (DIP)}

Per mantenere la logica applicativa isolata dal layer di input/output su console, 
il design applica rigorosamente il \textbf{Dependency Inversion Principle (DIP)}. 

Anziché far dipendere i Controller dall'implementazione concreta che gestisce i menu, 
li si fa dipendere dall'interfaccia astratta \texttt{Navigator}. 
In produzione, l'entry-point dell'applicazione inietta nei Controller il \texttt{NavigationManager} 
standard, che gestisce concretamente il flusso della CLI e le stampe a schermo. 

Oltre a favorire la modularità, questa scelta architetturale è stata pensata primariamente 
per abilitare la testabilità automatizzata del sistema. 
Disaccoppiando l'I/O, è infatti possibile iniettare nei Controller un componente fittizio 
(\texttt{StubNavigator}) che sopprime l'output e non blocca il thread in attesa di input 
da tastiera. L'implementazione e l'utilizzo pratico di questo Stub durante i test 
End-to-End sono approfonditi nella Sezione~\ref{sec:test2e2_architettura}.

\subsubsection{Architettura della Presentation (CLI)}

La modularità e la robustezza del livello di presentazione (CLI) sono garantite da 
due scelte implementative chiave che azzerano la duplicazione del codice:
\begin{itemize}
    \item \textbf{InputHandler centralizzato}: Una classe di utilità che incapsula l'uso di \texttt{java.util.Scanner}. 
    Si occupa di validare superficialmente gli input (controllando formati numerici, stringhe vuote, ecc.) 
    e implementa logiche di \textit{retry} automatico in caso di inserimento errato. 
    In questo modo i Controller ricevono sempre dati "puliti" e correttamente tipizzati.
    \item \textbf{Struttura Gerarchica dei Menu}: Il flusso applicativo è orchestrato da un coordinatore principale 
    (\texttt{CLIMenu}) che agisce da router verso sottomenu specializzati (\texttt{AuthMenu}, \texttt{GroupMenu}, \texttt{ExpenseMenu}, ecc.). 
    Ciascun sottomenu riceve l'\texttt{InputHandler} e le istanze dei Controller necessari, garantendo alta coesione e rispetto del principio di singola responsabilità (SRP).
\end{itemize}

\begin{lstlisting}[language=Java, caption={Esempio di logica di retry automatico nell'InputHandler}]
public BigDecimal readAmount(String prompt) {
    while (true) { // Loop di retry
        try {
            System.out.print(prompt);
            String input = scanner.nextLine().trim();
            BigDecimal amount = new BigDecimal(input);
            
            if (amount.compareTo(BigDecimal.ZERO) > 0) {
                return amount; // Input valido, esce dal loop
            }
            System.out.println("[ERROR] L'importo deve essere positivo.");
        } catch (NumberFormatException e) {
            System.out.println("[ERROR] Formato non valido. Inserisci un numero.");
        }
    }
}
\end{lstlisting}
